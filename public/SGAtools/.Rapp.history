matrix(rep(1,nrow*ncol), ncol=ncol)
rnorm(ncol, mean=col_means, sd=col_sigma)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + col_effect#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
#mat <- mat + row_effect#
#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + col_effect
displayMatrix(mat)
x = matrix(1,3,2)
x
x * c(1,2,3)
x * c(1,2)
x
x*c(1,2)
t(x)
t(x)*c(1,2)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
#mat <- mat + row_effect#
#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)
displayMatrix(mat)
x = c(0.2, 0.7,1.5,1.9)
x
mean(x)
plot(x)
lowess(x)
lowess(x, f=0.01)
lowess(x, f=1)
x+mean(x)
plotx
plot(x)
x/mean(x)
lines(x/mean(x), col=2)
lines(x/mean(x)*2, col=2)
lines(x/mean(x)*.5, col=2)
x = c(0.1, 1.2,2.2,2.5)
plot(x)
lines(x/mean(x), col=2)
lines(x/mean(x)*.5, col=2)
?nrand
runif(5, 0,0.5)
lines(x/mean(x)*.0.01, col=2)
lines(x/mean(x)*0.01, col=2)
lines(x/mean(x)*0.3, col=2)
lines(x/mean(x)*0.6, col=2)
x = 1:32
x/2
x
floor(x/2)
round(x/2)
x/2
ceiling(x/2)
rnrm = 1:nrow#
rdbl = ceiling(nrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)
rnrm
rdbl
cnrm
cdbl
sample(1:10, 1)
x= c(1,2,3,4,5)
sample(x)
sample(x, 1, replace=FALSE)
sample(x, 5, replace=FALSE)
i = 1
i++
;
quads_to_smooth = 20#
rand_pairs = matrix(NA, length(unique(rdbl))*length(unique(cdbl)), 1)#
#
i = 1#
for(i in 1:nrow/2){#
	for(j in 1:ncol/2){#
		rand_pairs[i,] = c(i,j)#
		i = i+1;#
	}#
}
quads_to_smooth = 20#
rand_pairs = matrix(NA, length(unique(rdbl))*length(unique(cdbl)), 1)#
#
i = 1#
for(i in 1:nrow/2){#
	for(j in 1:ncol/2){#
		rand_pairs[i,1] = c(i,j)#
		i = i+1;#
	}#
}
quads_to_smooth = 20#
rand_pairs = matrix(NA, length(unique(rdbl))*length(unique(cdbl)), 2)#
#
i = 1#
for(i in 1:nrow/2){#
	for(j in 1:ncol/2){#
		rand_pairs[i,] = c(i,j)#
		i = i+1;#
	}#
}
rand_pairs
rand_pairs = matrix(NA, length(unique(rdbl))*length(unique(cdbl)), 2)#
#
i = 1#
for(i in 1:length(unique(rdbl))){#
	for(j in 1:length(unique(cdbl))){#
		rand_pairs[i,] = c(i,j)#
		i = i+1;#
	}#
}
rand_pairs
rand_pairs = matrix(NA, length(unique(rdbl))*length(unique(cdbl)), 2)#
#
i = 1#
for(i in 1:length(unique(rdbl))){#
	for(j in 1:length(unique(cdbl))){#
		rand_pairs[i,] = c(i,j)#
		i = i+1;#
	}#
	i = i+1;#
}
rand_pairs
combn(c(1,2,3))
combn(c(1,2,3), c(1,2))
combn(c(1,2,3), c(1,2,3))
combn(10)
combn(10, 2)
?combn
?outer
outer(c(1,2,3), c(1,2))
outer(c(1,2,3), c(1))
outer(c(1,2,3), c(2))
outer(c(1,2,3))
outer(c(1,2,3), c(1,2,3))
expand.grid(c(1,2,3), c(1,2))
expand.grid(c(1,2,3), c(1,2,3,4))
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))
rand_pairs
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(rand_pairs),]
quads_to_smooth = 20#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:length(rand_pairs)),]
rand_pairs
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]
rand_pairs
head(rand_pairs)
rand_pairs[1,]
rand_pairs[1,][1]
rand_pairs[1,][1]/2
as.integer(0.5)
x = c(1,2)
y = c(3,4)
expand.grid(x,y)
expand.grid(x,y)[[1]]
x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])
x
y
ind = which(rdbl == x)#
	x = rnrm[ind]
ind
x
ind = which(cdbl == y)#
	y = cnrm[ind]
y
exp = expand.grid(x,y)
exp
r = runif(1, 0.5,1);
r
mat[exp[[1]], exp[[2]]]
mat[x,y]
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 20#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	r = runif(1, 0.5,1);#
	c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = mat[x,y] + c#
	rand_pairs = rand_pairs[2:length(rand_pairs),]#
}
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 200#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	r = runif(1, 0.5,1);#
	c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = mat[x,y] + c#
	rand_pairs = rand_pairs[2:length(rand_pairs),]#
}
displayMatrix(mat)
x = c(0.2,1.2,3.2,3.9)
plot(x)
lines(x/mean(x)*.2, col=2)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 20#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	r = runif(1, 0.3,1);#
	c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = mat[x,y] + c#
	rand_pairs = rand_pairs[2:length(rand_pairs),]#
}
displayMatrix(mat)
library(reshape)#
library(ggplot2)#
#
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 20#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	r = runif(1, 0.1,0.5);#
	c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = mat[x,y] + c#
	rand_pairs = rand_pairs[2:length(rand_pairs),]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 20#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	#r = runif(1, 0.1,0.5);#
	#c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.1)#
	rand_pairs = rand_pairs[2:length(rand_pairs),]#
}#
#
displayMatrix(mat)
warnings()
x
y
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 20#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]
dim(rand_pairs)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 200#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	#r = runif(1, 0.1,0.5);#
	#c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.1)#
	rand_pairs = rand_pairs[2:length(rand_pairs),]#
}
displayMatrix(mat)
warnings()
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 200#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	#r = runif(1, 0.1,0.5);#
	#c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.1)#
	print(paste(x,y))#
	rand_pairs = rand_pairs[2:length(rand_pairs),]#
}
rand_pairs
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 200#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]
head(rand_pairs)
rand_pairs = rand_pairs[2:length(rand_pairs),]
head(rand_pairs)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 200#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]
length(rand_pairs)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 200#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	#r = runif(1, 0.1,0.5);#
	#c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.1)#
	print(paste(x,y))#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
library(reshape)#
library(ggplot2)#
#
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	#r = runif(1, 0.1,0.5);#
	#c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.5)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	ind = which(rdbl == x)#
	x = rnrm[ind]#
	ind = which(cdbl == y)#
	y = cnrm[ind]#
	#x and y are now our actual indicies of the quad#
	#r = runif(1, 0.1,0.5);#
	#c = mat[x,y]/ (mean(mat[x,y])*r);#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.2), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.2, 0.6), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 10#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 40#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	if(x == 1 | x == 2 | y==1 | y==2){#
		i = i - 1#
		next#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	if(x == 1 | x == 2 | y==1 | y==2){#
		next#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	if(x == 1 | x == 2 | y==1 | y==2){#
		next#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	if(x<=2 | y<=2 | x == 31 | x == 32 | y == 47 | y == 48){#
		next#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 20#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	if(x == 1 | y == 1 | x == 16 | y == 24){#
		next#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 25#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	if(x == 1 | y == 1 | x == 16 | y == 24){#
		next#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 25#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	while(x == 1 | y == 1 | x == 16 | y == 24){#
		x = as.integer(rand_pairs[1,][1])#
		y = as.integer(rand_pairs[1,][2])#
		rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
ncol = 48#
nrow = 32#
plate_mean = 3#
sigma = 0.8#
mat = matrix(rnorm(ncol*nrow, mean = plate_mean, sd = sigma), nrow, ncol);#
#
#Row effect#
row_means = floor(sort(abs(rnorm(nrow/2,sd=5)), decreasing=TRUE))+1#
row_means = c(row_means, floor(sort(abs(rnorm(nrow/2,sd=5))))+1)#
row_sigma = 0.1#
row_effect = matrix(rep(1,nrow*ncol), ncol=ncol)*rnorm(nrow, mean=row_means, sd=row_sigma)#
mat <- mat + row_effect#
#
#Column effect#
col_means = floor(sort(abs(rnorm(ncol/2,sd=5)), decreasing=TRUE))+1#
col_means = c(col_means, floor(sort(abs(rnorm(ncol/2,sd=5))))+1)#
col_sigma = 0.1#
col_effect = t(matrix(rep(1,nrow*ncol), ncol=ncol))*rnorm(ncol, mean=col_means, sd=col_sigma)#
mat <- mat + t(col_effect)#
#
#Make quads similar #
rnrm = 1:nrow#
rdbl = ceiling(rnrm/2)#
cnrm = 1:ncol#
cdbl = ceiling(cnrm/2)#
#
#Max 384#
quads_to_smooth = 100#
#
#Generate random pairs representing quads and randomize the rows#
rand_pairs = expand.grid(unique(rdbl), unique(cdbl))#
rand_pairs = rand_pairs[sample(1:dim(rand_pairs)[1]),]#
rand_pairs2 = rand_pairs#
#
for(i in 1:quads_to_smooth){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	mat[x,y] = rnorm(4, mean=mean(mat[x,y]), sd=0.3)#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
#Add genetic interactions#
num_gis = 35#
for(i in 1:num_gis){#
	#Our random pair#
	x = as.integer(rand_pairs[1,][1])#
	y = as.integer(rand_pairs[1,][2])#
	while(x == 1 | y == 1 | x == 16 | y == 24){#
		x = as.integer(rand_pairs[1,][1])#
		y = as.integer(rand_pairs[1,][2])#
		rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
	}#
	x = rnrm[which(rdbl == x)]#
	y = cnrm[which(cdbl == y)]#
	#x and y are now our actual indicies of the quad#
	r = matrix(runif(4, 0.0, 0.5), 2,2);#
	mat[x,y] = mat[x,y] * r#
	rand_pairs = rand_pairs[2:dim(rand_pairs)[1],]#
}#
#
displayMatrix(mat)
plot(sort(runif(100,0,1)))
plot(sort(runif(1000,0,1)))
plot(sort(runif(1000,0,0.5)))
plot(sort(runif(1000,0.2,0.5)))
plot(sort(runif(1000,0.3,0.5)))
plot(c(1,2,3))
ls
str()
str(c(1,23))
str(c('a',1,'b'))
install.packages('rgenoud')
library()
.libPaths()
install.packages('rgenoud')
remove.packages('rgenoud')
install.packages('rgenoud')
R
p = c(rep(0.4, 8), 0.6, 0.4, 0.6, 0.7, 0.4, 0.7, rep(0.6, 4), 0.7, 0.6)
p
length(p)
p
p/21
sum(p/21)
x = p/21
x = x/sum(x)
x
sum(x)
data.frame(x)
p
sum(p)
10.3/21
p/21 / (sum(p)/21)
p[13]
p[10]
p
p/20
p / sum(p)
p/20 / sum(p/20)
p
data.frame(p)
sum(p)
fresh_file_matrix = matrix(1:9, 3,3)
fresh_file_matrix
minimum_measurement <- apply(fresh_file_matrix[,3:29],1,min)
minimum_measurement <- apply(fresh_file_matrix,1,min)
minimum_measurement <- apply(fresh_file_matrix[,3:29],1,min)
minimum_measurement
fresh_file_matrix <- cbind(fresh_file_matrix, minimum_measurement)
fresh_file_matrix
fresh_file_matrix[fresh_file_matrix[,ncol(fresh_file_matrix)]>10^3.5,]
fresh_file_matrix[,ncol(fresh_file_matrix)]
minimum_measurement <- apply(fresh_file_matrix[,3:29],1,function(row){#
	if(min(row) > 1){#
		row#
	}#
})
minimum_measurement <- apply(fresh_file_matrix,1,function(row){#
	if(min(row) > 1){#
		row#
	}#
})
minimum_measurement
unlist(minimum_measurement)
do.call('rbind', minimum_measurement)
chooseCRANmirror()
install.packages('seqLogo')
chooseCRANmirror()
install.packages('seqLogo')
chooseCRANmirror()
install.packages('seqLogo')
getForm("http://www.google.com/search", .params = c(hl="en", lr="", ie="ISO-8859-1",  q="RCurl", btnG="Search"))
install.packages('RHTMLForms')
setwd('/Users/omarwagih/Desktop/boone-summer-project-2012/web/sgatools-v2/public/SGAtools/')
source('SGAtools.R')
l = list.dirs('')
l
list.dirs('~/Desktop/new Zeocin to Normalize')
list.files('~/Desktop/new Zeocin to Normalize')
list.files('~/Desktop/new Zeocin to Normalize', recursive=T)
x = list.files('~/Desktop/new Zeocin to Normalize', recursive=T)
tn = x[grep('\\.dat', x)]
tn
paste('~/Desktop/new Zeocin to Normalize', tn)
tn=paste('~/Desktop/new Zeocin to Normalize', tn)
r=readSGA(tn)
x = list.files('~/Desktop/new Zeocin to Normalize', recursive=T, full.names=T)
x
tn = x[grep('\\.dat', x)]
tn
r=readSGA(tn)
head(r[[1]])
normalized = normalizeSGA(r, linkage.cutoff=-1)
normalized = lapply(r, normalizeSGA, linkage.cutoff=-1)
length(normalized)
data = normalized[[1]]
ave.name = paste0('/Users/omarwagih/Desktop/normalized_laura',data$plateid[1])
ave.name
save.name = paste0('/Users/omarwagih/Desktop/normalized_laura/',data$plateid[1])
save.name
for(data in normalized){#
	save.name = paste0('/Users/omarwagih/Desktop/normalized_laura/normalized_',data$plateid[1])#
	write.table(data, save.name,  row.names=F, quote=F, sep="\t")#
}
